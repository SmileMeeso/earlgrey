function main(){
  //sheet clear
  //sheetClear();
  
  //processList와 errorList를 저장할 배열 선언
  var processListArray = [];
  var errorListArray = [];
  
  //테스트 대상 시트 목록
  var testSheetArr = [//'1iHImkn-pfDpMwew-IgoUcpaO5y-fo3mm3tJRjeSMBeE', //주문서(CONTENT_TYPEx)
                      //'1QEp12kWRhncIlf9KrZRCl4tC216fzyIP6wMR2N3arpM', //여행11(CONTENT_TYPEx)
//                      '1JyUHKcqeW2LUPA5VwEdQ9rizRd4q7TVhiXks7w5eOJ8', //여행11번가(content_Type o, content_type 중복)
                      //'1Gmz40fMsJjtAnjCahTKTfRq6-1GImtcKsfLoAx_5_aU', //여행11번가 테스트용(content_type o , content_Type 미중복)
    '1NX81QHDPxg6tKKbsH2Yl30NKGy6tOHqKP4fcQsesYAw'
                     ];
  
  //테스트 시트
  var testSpreadSheet2 = SpreadsheetApp.openById('1K6MpkMg_u2hkuG3V9pcWm1cyg7MqP_koiPa0I6qNeCY');
  var testSheet2 = testSpreadSheet2.getSheetByName('통합 로그정의서');
  
  var testSheetArrLength = testSheetArr.length;
  testLog("처리할 정의서 갯수 :" + testSheetArrLength);
  
  for(var zz = 0; zz < testSheetArrLength; zz++){
    var testSpreadSheet = SpreadsheetApp.openById(testSheetArr[zz]);
    var testSheet = testSpreadSheet.getSheetByName('PC');
    
    var arr = readEachSheet_v3(testSpreadSheet.getId(), testSheet, getTime('STRING'));
    
    //결과 Object의 key 값에 따라 배열 저장 분기
    if(arr.processList){
      processListArray = processListArray.concat(arr.processList);
    }else if(arr.errorList){
      errorListArray = errorListArray.concat(arr.errorList);
    }else{
      
    }
  }
  
  //시트 처리가 끝난 후 오류 로그와 쿼리 로그를 각각 작성하는 함수 필요
  if(processListArray.length != 0 ){
    testLog("정의서 정보를 작성합니다. : " + processListArray.length);
    writeSheet(testSheet2, processListArray);
  }
  if(errorListArray.length != 0){
    testLog("오류 로그를 작성합니다. : " + errorListArray.length);
    logForVerification(errorListArray);
  }
}

/************************** 정의서 검증 함수 **************************/
//passedSheet로 받은 정의서를 읽어서 정의서 정보 또는 오류 정보를 object로 리턴
//오류가 없는 경우는 정답지 시트의 형식에 맞는 2차 배열을 object로 wrapping하여 리턴
//오류가 있는 경우는 오류 로그 시트의 형식에 맞는 2차 배열을 object로 wrapping하여 리턴
//오류 유무에 무관하게 리턴하는 객체(=returnObj)는 같으나 객체 내부 값이 달라짐(오류인 경우 returnObject = {errorList : []}, 오류가 없는 경우 returnObject = {processList : []})

//오류는 2종류
// 1)정의서 형식에서 비롯된 오류들
// 2)readEachSheet 함수 running시 생기는 오류들

//readEachSheet 예외

//passedObject = {PageAttribute : [page_id, [poc_clf], [os_name]], BodyAttribute : [[state, action_id, body(JSON)]], SpreadSheetID : spreadSheetID, SheetID : sheetID, TimeStamp : timeStamp, errorList : []}
function readEachSheet_v3(passedSpreadSheetID, passedSheet, passedTime, pocForModule, moduleCount){//main에서 받는 parameter은 3개
  testLog("정의서 검증을 시작합니다. : " + passedSpreadSheetID);
  
  var spreadSheetID = passedSpreadSheetID;
  var targetSheet = passedSheet;
  var timeStamp = passedTime;
  
  var sheetID = targetSheet.getSheetId();
  var lastRow = targetSheet.getLastRow();
  var lastColumn = targetSheet.getLastColumn();
  
  //오류 핸들러 생성
  var errorHandler = new ErrorCollector(spreadSheetID);
  
  if(!moduleCount){
    var thisModuleCount = 0;
  }else if(moduleCount >= 5){
    // 순환모듈 오류
    return errorHandler.coerciveBreak(2, p, 'cursiveModuleException');
  }else{
    var thisModuleCount = moduleCount + 1;
  }
  
  var errorFlag = false; //검사하다가 오류 발견시 true, true시 모듈 생성 안함
  
  //lastRow와 lastColumn을 가져올 수 없는 경우 오류 캐치
  
  //lastRow : 0 lastColumn : 0일 때 exception 추가
  
  try{
    var content = targetSheet.getRange(1, 1, lastRow, lastColumn).getValues();
  }catch(e){
    return errorHandler.coerciveBreak(2, 1, 'contentGetValuesException : ' + e);
  }
  
  //필요한 변수 초기화
  var ObjectForExamination = {
    pageAttribute : [], 
    BodyAttribute : [],
    SpreadSheetID : spreadSheetID,
    SheetID : sheetID,
    TimeStamp : timeStamp,
    errorList : []
  } //{PageAttribute : [page_id, [poc_clf], [os_name]], BodyAttribute : [[state, action_id, body(JSON)], ...], SpreadSheetID : spreadSheetID, SheetID : sheetID, TimeStamp : timeStamp, errorList : []}
  var returnObject = {}; //return을 위한 Object, returnObject = {processList : [], errorList : []}
  
  /************************** content object 처리 **************************/
  //코드 가독성과 유지보수를 위해 분석할 object를 따로 만들어 사용
  //contentObj = {sheetType : '', page_id : '', poc_clf : [], moduleURL : [], logData : {state : [], gesture : [], area : [], label : [], body : [[]], content_type : []}}
  try{
    var contentObj = mapGenerator(content); 
  }catch(e){
    //contentObj 생성 오류
    return errorHandler.coerciveBreak(2, 1, 'mapGeneratorException : ' + e);
  }
  testLog("contentObj : " + JSON.stringify(contentObj));
  
  //content_type 리스트 유무 검사
  var content_typeFlag = false;
  
  if(contentObj.logData.content_type[0]){
    var content_typeDIC = getContent_typeDIC();
    
    content_typeFlag = true;
  }
  
  /************************** PageAttribute 핸들링 **************************/
  //if분기로 검증 후 배열에 '행 번호'로 저장 → 배열에 저장된 오류를 verificationArray에서 검증
  //일반 정의서와 모듈 정의서로 분기
  var sheetType = contentObj.sheetType;
  
  //1. 일반 정의서인 경우
  if(!sheetType.match(/module/)){
    //page_id
    //페이지 ID 행에 값이 있는가만 검증, 틀린 값 여부는 검증하지 않음
    if(contentObj.page_id != ''){
      ObjectForExamination.pageAttribute[0] = contentObj.page_id;
    }else{
      //page_id 없음 오류
      errorHandler.errorCollect(2, 5, 'poc_clf', 'NoPageIDException');
      ObjectForExamination.pageAttribute[0] = 3;
    }
    
    //poc정보 생성
    var pocINFO = pocGenerator(contentObj.poc_clf);
    
    //poc_clf, os_name
    if(!pocINFO.error){
      ObjectForExamination.pageAttribute[1] = pocINFO.poc_clf;
      ObjectForExamination.pageAttribute[2] = pocINFO.os_name;
    }else if(pocINFO.error){
      //규격과 다른 poc가 있을 경우 오류
      errorHandler.errorCollect(2, pocINFO.error, 'poc_clf', 'NonstandardPocInfoException');
    }
    
  //2. 모듈정의서인 경우
  }else if(sheetType.match(/module/)){ 
    if(pocForModule){ 
      //page_id
      //모듈의 경우 page_id 검증은 생략
      ObjectForExamination.pageAttribute[0] = 'module';
      
      //재귀함수 호출인 경우 poc_clf 정보를 parameter에서 받는다
      //일반 정의서의 POC와 모듈정의서의 POC가 다른 경우가 있음. 여기서 해당 경우 핸들링(나중)
      var poc_clfFromReferer = pocForModule;
      
      ObjectForExamination.pageAttribute[1] = poc_clfFromReferer.poc_clf;
      ObjectForExamination.pageAttribute[2] = poc_clfFromReferer.os_name;
    }else{
      //module 정의서를 parameter로 받은 경우
      testLog('모듈입니다');
      return ; //리턴 값 검토 (오류 메세지가 필요할까요..............)
    }
  }
  
  /************************* BodyArrtibute 핸들링 ***************************/
  //contentObj.logData : {state : [], gesture : [], area : [], label : [], content_type : [], body : [[]]}
  //BodyAttribute : [[state, action_id, body(JSON)], ...]
  
  var logData = contentObj.logData;
  
  var stateMap = ['서비스중', '삭제', '추가', '수정', '삭제요청']; //state 맵
  var gestureMap = ['click', 'impression', 'change', 'swipe', 'page_show', 'dom_content_loaded', 'mouseover']; //gesture맵
  var gestureOnlyActionID = ['page_show', 'dom_content_loaded']; //area, label을 갖지 않는 gesture의 맵(gesture로만 이루어진 actionID)
  
  if(logData.state.length == logData.body.length){ //길이 비교 필요
    var logDataLength = logData.state.length;
    
    for(var p = 0; p < logDataLength; p++){
      //초기화
      ObjectForExamination.BodyAttribute[p] = [];
      var temp = [] //[state, action_id, body(JSON)]
      
      //state
      var thisState = logData.state[p][0];
      
      if(stateMap.indexOf(thisState) >= 0){
        temp[0] = thisState;
      }else{
        //지정된 state가 아닌 경우 오류, 비어있을 경우 오류
        errorHandler.errorCollect(2, p, 'logData.state', 'NonstandardStateException');
      }
      
      //action_id
      var tempActionID = []; //[gesture, area, label]
      
      //..........gesture
      var thisGesture = logData.gesture[p][0];
      
      if(gestureMap.indexOf(thisGesture) != -1){
        if(gestureOnlyActionID.indexOf(thisGesture) != -1){
          temp[1] = thisGesture;
        }else{
          tempActionID[0] = thisGesture;
        }
      }else{
        //지정된 gesture가 아닌 경우 오류 혹은 비어있는 경우 오류
        errorHandler.errorCollect(2, p, 'logData.gesture', 'NonstandardGestureException');
      }
      
      //..........area
      var thisArea = logData.area[p][0];
      
      if((thisArea != '') && (!temp[1])){
        tempActionID[1] = thisArea;
      }else{
        if(temp[1]){
          //gestureOnlyActionID = ['page_show', 'dom_content_loaded']에 들어가는 경우
        }else{
          //area이 없는 경우 오류
          errorHandler.errorCollect(2, p, 'logData.area', 'NonstandardAreaException');
        }
      }
      
      //..........label
      var thisLabel = logData.label[p][0];
      
      //pui핸들링 없음 : 추가 예정
      if((thisLabel != '') && (!temp[1])){
        tempActionID[2] = thisLabel;
      }else{
        if(temp[1]){
          //gesture == page_show || dom_content_loaded
        }else{
          //label이 없는 경우 오류
          errorHandler.errorCollect(2, p, 'logData.label', 'NonstandardLabelException');
        }
      }
      
      //gesture이 page_show 또는 dom_content_loaded가 아니고 gesture, area, label이 존재할 경우 action_id를 생성함
      if(!temp[1] && (tempActionID.length == 3)){
        temp[1] = tempActionID.join('.');
      }
      
      //tempBody 변수에 content_type 연계변수를 넣고 body 변수들을 합침
      var tempBody = [];
      
      var arrayLengthBeforeFilter = 0; //최종 body변수 배열에서 중복을 제거하기 전의 길이 초기화
      var arrayLengthAfterFilter = 0; //최종 body변수 배열에서 중복을 제거한 후의 길이 초기화
      
      //content_type
      if(content_typeFlag){
        if(logData.content_type[p] != []){
          if(content_typeDIC[logData.content_type[p]]){
            //사전에 있으면 넣는다
            tempBody = content_typeDIC[logData.content_type[p]];
          }else{
            //사전에 없는 값은 오류
            errorHandler.errorCollect(2, p, 'logData.content_type', 'NonstandardContent_typeException');
          }
        }
      }
      
      //body
      //1)body 배열 합치기
      var thisBody = logData.body[p];
      
      tempBody = tempBody.concat(thisBody); //나중에 수정 ㅠㅠ
      
      //공백 제거와 중복 제거를 함께 하려고 했으나 공백제거와 중복제거 로직이 바뀔 수 있으니 따로 하는걸로.........
      //2)body 공백 제거
      tempBody = tempBody.filter(function(x){
        return x != '';
      });
      arrayLengthBeforeFilter = tempBody.length;
      
      //3)body 중복 제거
      tempBody = tempBody.reduce(function(accumulator, x, idx, array){
        if(accumulator.indexOf(x) == -1){
          accumulator.push(x);
        }
        return accumulator;
      }, []);
      arrayLengthAfterFilter = tempBody.length;
      
      if(arrayLengthBeforeFilter != arrayLengthAfterFilter){
        //body에서 중복된 값이 있으면 오류 (기능억제)
        //errorHandler.errorCollect(2, p, 'logData.body', 'DuplicationBodyException');
      }
      
      //4)JSON 형태로 변경
      tempBody = tempBody.reduce(function(accumulator, x, idx){
        if(x != ''){
          accumulator.push('"' + x + '"');
        }
        return accumulator;
      }, []);
      tempBody = '{"body" : [' + tempBody + ']}';
      
      //5)temp Array에 저장
      temp.push(tempBody);
      
      //temp변수에 저장된 값을 ObjectForExamination 객체에 저장
      if(temp.length == 3){
        ObjectForExamination.BodyAttribute[p] = temp;
      }else{
        //logData배열 생성 오류
        errorHandler.errorCollect(2, p, 'logData', 'ArrayGeneratorException');
      }
    }
  }else{
    //logData 하위 Object들의 value length값이 같지 않음
    errorHandler.errorCollect(2, 0, 'logData', 'ValueLengthException'); //0은 임시값
  }
  
  testLog(JSON.stringify(ObjectForExamination));
  /************************* 모듈 포함 여부 검사 ***************************/
  //contentObj.moduleURL 검사
  //정의서에 오류가 있다면 flag on, flag가 on인 경우 모듈 정답지 생성 건너뜀
  //모듈 정보를 이전 함수에서 받아오면 속도가 더 빨라질 것 같은뎅.......(나중)
  if(contentObj.moduleURL[0]){
    if(!errorFlag){
      var modules = contentObj.moduleURL;
      var modulesLength = modules.length;
      
      for(var m = 0; m < modulesLength; m++){
        testLog('modules[m] : ' + JSON.stringify(modules[m]));
        if(modules[m].match(/https/)){
          //모듈 정보
          var moduleSpreadSheetID = /spreadsheets\/d\/([a-zA-Z0-9-_]+)/.exec(modules[m].toString())[1]; //정규식 캡처 방식이라 return이 array임
          var moduleSheetID =  /gid=([0-9]+)/.exec(modules[m].toString())[1]; //정규식 캡처 방식이라 return이 array임
          var moduleSpreadSheet = SpreadsheetApp.openById(moduleSpreadSheetID);
          var moduleSpreadSheetName = moduleSpreadSheet.getName();
          
          //module search 함수 호출하여 모듈의 스프레드 시트 중 moduleSheetID와 같은 SheetID를 가지는 시트만 리턴
          var moduleSheet = searchSheet(moduleSpreadSheet, moduleSheetID);
          
          var objectForModuleBody = readEachSheet_v3(moduleSpreadSheetID, moduleSheet, timeStamp, pocINFO, thisModuleCount);
          testLog('objectForModuleBody : ' + JSON.stringify(objectForModuleBody));
          testLog('objectForModuleBody.ErrorFlag : ' + JSON.stringify(objectForModuleBody.ErrorFlag));
          
          //모듈 처리 후 어떻게 합칠지 정해야 함
          //module 정의서에 오류가 있을 경우 body를 합치지 않음
          if(!objectForModuleBody.ErrorFlag){
            ObjectForExamination.BodyAttribute = ObjectForExamination.BodyAttribute.concat(objectForModuleBody.BodyAttribute);
          }else{
            errorHandler.errorCollection = errorHandler.errorCollection.concat(objectForModuleBody.errorList);
            testLog('objectForModuleBody.errorList : ' + JSON.stringify(objectForModuleBody.errorList));
          }
        }
      }
    }
  }
  
  testLog('errorHandler.getErrorCollection : ' + JSON.stringify(errorHandler.getErrorCollection));
  
  //리턴분기
  if(!errorHandler.getErrorCollection){
    //처리한 정의서에 오류가 없는 경우 엑셀 배열 형식으로 만들어 호출 함수에 리턴
    ObjectForExamination.ErrorFlag = false;
    testLog('errorFlag' + JSON.stringify(ObjectForExamination.ErrorFlag));
    
    if(pocForModule){
     returnObject = ObjectForExamination;
    }else{
     returnObject = arrayGenerator(ObjectForExamination);
    }
  }else{
    //처리한 정의서에 오류가 있는 경우 오류 배열을 호출 함수에 리턴
    testLog('errorFlag' + JSON.stringify(ObjectForExamination.ErrorFlag));
    ObjectForExamination.ErrorFlag = true;
    
    testLog('오류 생성');
    ObjectForExamination.errorList = errorHandler.errorCollection;
    returnObject = ObjectForExamination;
  }
  
  return returnObject;
}

/************************** errorCollector 함수 **************************/
//errorCollector(오류 레벨, 오류 발생 행 정보 배열, 오류 발생 그룹, 오류 정보)
function testFunc(){
  var errorCollect = new ErrorCollector('testSHeet');
  var newarr = ['aaa', 'aa']
  
  errorCollect.errorCollector(newarr);
  errorCollect.getErrorCollection;
  
  testLog('errorCollection : ' + JSON.stringify(errorCollect.getErrorCollection));
}

function ErrorCollector(pspreadSheetID){
  var _errorDic = {};
  var _spreadSheetID = pspreadSheetID;
  var _errorCollection = [];
  
  return {
    errorCollector : function(arr){
      _errorCollection.push(arr);
    },
    getErrorCollection : function(){
      testLog('_errorCollection : ' + JSON.stringify(_errorCollection));
      return _errorCollection
    }
  }
}

  
/*
function ErrorCollector(pspreadSheetID){
  var _errorDic = {}; //
  var _spreadSheetID = pspreadSheetID;
  var _errorCollection = [];
  
  //오류를 배열에 저장하는 함수
  function _errorCollect(level, num, group, errorInfo){
    //레벨 설정 후 if문으로 분기
    this.errorCollection.push(["[" + spreadSheetID + "] " + group + "처리 중 " + num + "에서" + errorInfo + " 오류가 발생했습니다."]);
  }
  
  //인스턴트 오류 메세지 출력
  this.coerciveBreak = function(level, group, errorInfo){
    testLog("coerciveBreak를 호출합니다.");
    var instantErrorMsg = [[level], [spreadSheetID + "처리 중 " + errorInfo + " 오류가 발생했습니다."]];
    
    return {errorList : instantErrorMsg};
  }
}
*/

/************************** Array를 생성하는 함수 **************************/
//검사 완료된 Object를 받아 배열을 생성하는 함수
//배열을 생성한 후 processList를 key로 갖는 Object를 리턴
//passedObject = {PageAttribute : [page_id, [poc_clf], [os_name]], BodyAttribute : [[state, action_id, body(JSON)]], SpreadSheetID : spreadSheetID, SheetID : sheetID, TimeStamp : timeStamp, errorList : []}
function arrayGenerator(passedObject){
  var pageAttribute = passedObject.pageAttribute;
  var bodyAttribute = passedObject.BodyAttribute;
  var timeStamp = passedObject.TimeStamp;
  var rule_id = passedObject.SpreadSheetID;
  
  var moduleErrorList = passedObject.errorList; //안씀
  
  var returnArray = [];
  var returnObject = {};
  
  var pageID = pageAttribute[0];
  var poc_clf = pageAttribute[1];
  var os_name = pageAttribute[2];
  
  var pocCount = poc_clf.length;
  var bodyCount = bodyAttribute.length;
  var arrayLength = 0;
  
  for(var ee = 0; ee < pocCount; ee++){
    for(var bb = 0; bb < bodyCount; bb++){
      arrayLength = returnArray.length;
      returnArray[arrayLength] = [];
      
      //배열 생성
      returnArray[arrayLength][0] = timeStamp; //timeStamp
      returnArray[arrayLength][1] = rule_id; //rule_id
      returnArray[arrayLength][2] = bodyAttribute[bb][0]; //state
      returnArray[arrayLength][3] = poc_clf[ee]; //poc_clf
      returnArray[arrayLength][4] = os_name[ee]; //os_name
      returnArray[arrayLength][5] = pageID; //page_id
      returnArray[arrayLength][6] = bodyAttribute[bb][1]; //action_id
      returnArray[arrayLength][7] = bodyAttribute[bb][2]; //body
    }
  }
  returnObject.processList = returnArray;
  
  return returnObject;
}

/************************** 모듈 search 함수 **************************/
//module 정의서 링크에서 추출한 SheetID(pSheetID)를 가지는 sheet를 parameter로 받은 spreadsheet(pSpreadSheet)에서 찾는 함수
//캐시에 모듈 시트를 저장하여 활용하는 것은 속도가 너무 느려져서 삭제
function searchSheet(pSpreadSheet, pSheetID){
  var Sheets = pSpreadSheet.getSheets();
  var SheetID = pSheetID;
  
  var SheetsLength = Sheets.length;
  for(var kk = 0; kk < SheetsLength; kk++){
    if(SheetID == Sheets[kk].getSheetId()){
      return Sheets[kk];
    }
  }
}

/************************** 시간함수 **************************/
//시간을 hhmnssMISS로 리턴
//type = 'NUMBER' || 'STRING' || 'SAPERATE'
function getTime(type, length){
  Date.prototype.timemaker = function(){
    var hh = this.getHours().toString();
    var mn = this.getMinutes().toString();
    var ss = this.getSeconds().toString();
    var miss = this.getMilliseconds().toString(); //to string

    if(hh.length == 1){
      hh = '0' + hh;
    }
    if(mn.length == 1){
      mn = '0' + mn;
    }
    if(ss.length == 1){
      ss = '0' + ss;
    }
    if(miss.length != 3){
      var addCount = 3 - miss.length;
      for(var zz = 0; zz < addCount; zz++){
        miss = '0' + miss;
      }
    }
    
    if(type == 'SEPARATE'){
       return "[" + [hh,mn,ss,miss].join(":") + "]";
    }else{
      return [hh, mn, ss, miss].join('');
    }
  }
  
  var d = new Date();
  
  if(!length){  
    var length = d.timemaker().length;
  }
  
  if(type == 'NUMBER'){
    return Number(d.timemaker().substring(0, length));
  }else if(type == 'STRING'|| type == 'SEPARATE'){
    return d.timemaker().substring(0, length);
  }
  //이외의 타입인 경우 뭐 리턴하지☆★☆★☆★☆★
}

/************************** timeout handler **************************/
function timeoutHandler(){
  
}

/************************** 오브젝트 생성 함수 **************************/
//..........return은 Object로
//returnObject = {sheetType : '', page_id : '', poc_clf : [], moduleURL : [], logData : {state : [], gesture : [], area : [], label : [], content_type : [], body : [[]]}}
//logData = {state : [], gesture : [], area : [], label : [], body : [[]]} ← 개인적으로 이게 좋아서 이거 채택
//logData = {1 : [state, gesture, area, label, body], 2 : [state, gesture, area, label, body] , 3 : [state, gesture, area, label, body], ...} ← 2안
//여기서 비어있는 부분은 ""로 됨. ""는 다른 함수에서 검사해서 오류 처리
function mapGenerator(Array){
  var content = Array;
  var lastRow = content.length;
  var returnObject = {};
  
  //요것도 객채맵으로 변경 예정
  returnObject.sheetType = content[0][0]; //이거 그대로 가져감(오류 검사를 위함 // 시트가 규격과 다를 경우!)
  returnObject.page_id = content[2][1];
  returnObject.poc_clf = content[4].slice(1).reduce(rowReader, []);
  returnObject.moduleURL = content[11].slice(1).reduce(rowReader,[]);
  returnObject.logData = logDataGenerator(content, lastRow);
  
  return returnObject;
}


/************************* 열 정리 함수 *************************/
//callback용
//1)빈칸이 아닌 경우 : 뭐라도 쓰여있을 경우 배열에 볷
//2)빈칸인 경우
//(1)그 칸만 비어있는 경우는 ''을 배열에 복사 
//(2)앞뒤 칸도 비어있을 경우 루프 탈출
//(3)첫 번째나 마지막 행이 비어있을 경우 ''을 배열에 복사
 //뭐라도 쓰여있을 경우
function rowReader(accumulator, x, idx, arr){
  if(x != ''){  //빈칸이 아닌 경우
    accumulator.push(x);
    return accumulator;
  }else{ //빈칸일 경우
    if((typeof arr[idx + 1] != 'undefined') && (typeof arr[idx - 1] != 'undefined')){
      if((arr[idx + 1] != '') || (arr[idx - 1] != '')){
        //앞, 또는 뒤에 내용이 있는 단순한 한 칸 빈칸일 경우 ''을 삽입한다.
        accumulator.push('');
      }else{//논리only
        if(idx == arr.length - 1){
          accumulator.pop();
        }else{
          
        }
      }
    }else{ //첫번째 행 또는 마지막 행인 경우
      if(idx == 0){
        //@@@@@@@@@@@@@@@@@구체화 필요 첫 번째 열 다음부터 정보가 없는 경우 poc 정보가 없는 것, 첫번째 열 한 칸만 비어있는 경우 한 칸 누락
        accumulator.push('');
      }else if(idx == arr.length - 1){ //마지막 행인 경우 어차피 이번 루프에서 끝남~ (마지막까지 갈 일이 있나 싶지만)
        accumulator.pop();
      }
    }
  }
  return accumulator;
}


/************************* poc_clf, os_name *************************/
function pocGenerator(array){
  //poc 추가되면 poc_clfANDos_nameMap 객체 수정하면 됨
  var poc_clfList = array;
  var poc_clfListLength = poc_clfList.length;
  
  var poc_clfANDos_nameMap = { // 정의서의 POC 구분(key) : [poc_clf, os_name](value)
    'MW' : ['mw', ''],
    'APP(Android)' : ['app', 'Android'],
    'APP(iOS)' : ['app', 'iOS'],
    'PC' : ['pc', '']
  }
  var returnObject = {
    poc_clf : [],
    os_name : []
  }
  
  for(var p = 0; p < poc_clfListLength; p++){
    if(poc_clfANDos_nameMap[poc_clfList[p]]){
      returnObject.poc_clf.push(poc_clfANDos_nameMap[poc_clfList[p]][0]);
      returnObject.os_name.push(poc_clfANDos_nameMap[poc_clfList[p]][1]);
    }else if(poc_clfList[p] == ''){
      //poc_clf가 비어있는 경우
    }else{
      //poc_clf가 규격 외인 경우
      returnObject.error = p;
    }
  }
  return returnObject;
}
/************************* 오류 코드를 불러오는 함수 *************************/
//content_type 사전이랑 같기 때문에 합치고 싶은데 유지보수 측면에서 ;_;
function getExceptionList(){
  var exceptionList = [];
  var exceptionName = [];
  
}

/************************* content_type 사전을 불러오는 함수 *************************/
//returnObj = {content_type값1 : [body1, body2, body3, ...], content_type값2 : [body1, body2, body3, ...], ...}
//content_type 관련 obj는 전역변수로 하고싶기도...
function getContent_typeDIC(){
  var content_type = [];
  var content_typeBodys = [];
  
  //content_type 사전에서 읽어오고 싶은데 그러면 쓸데없이 요청이 많아져서 속도가 느려지므로 일단 직접 배열 값 넣는걸로 ㅠㅠ
  content_type = ['PRODUCT', 'BANNER', 'CATEGORY', 'SELLER', 'EXHIBITION', 'TEXT', 'BRAND,CATALOG', 'STORE', 'META_CATEGORY', 'ATTRIBUTE', 'MOVIE', ''];
  content_typeBodys = [['content_type', 'content_no', 'position_l1', 'position_l2', 'last_discount_price'], 
                       ['content_type', 'content_no', 'position_l1', 'position_l2', 'link_url', 'trc_no'], 
                       ['content_type', 'content_no', 'position_l1', 'position_l2'], 
                       ['content_type', 'content_no', 'position_l1', 'position_l2'],
                       ['content_type', 'content_no', 'position_l1', 'position_l2'],
                       ['content_type', 'content_no', 'position_l1', 'position_l2', 'trc_no'],
                       ['content_type', 'content_no', 'position_l1', 'position_l2'],
                       ['content_type', 'content_no', 'position_l1', 'position_l2'],
                       ['content_type', 'content_no', 'position_l1', 'position_l2'],
                       ['content_type', 'content_no', 'position_l1', 'position_l2'],
                       ['content_type', 'content_no', 'position_l1', 'position_l2'],
                       ['']
                      ];
  
  return objGenerator(content_type, content_typeBodys);
}

/************************* 객체 만드는 함수 *************************/
//배열 1개 : 모든 key의 값이 []인 객체 생성
//배열 2개 : keyArr 배열의 값을 key로 하며, valueArr 배열의 값을 값으로 value로 하는 객체 생성
function objGenerator(keyArr, valueArr){
  var keyVal = keyArr;
  
  var returnObj = {};
  
  var keyValLength = keyVal.length;
  
  if(valueArr){
    if(keyArr.length == valueArr.length){
      var valueVal = valueArr;
      
      for(var kkk = 0; kkk < keyValLength; kkk++){
        returnObj[keyVal[kkk]] = valueVal[kkk];
      }
    }else{
      throw "objGeneratorArrayLengthException";
    }
  }else{
    for(var kkk = 0; kkk < keyValLength; kkk++){
        returnObj[keyVal[kkk]] = [];
    }
  }
  
  return returnObj;
}

function logDataGenerator(pcontent, plastRow){ //함수 외부함수로 나눌까................................... 
  var content = pcontent;
  var lastRow = plastRow;
  
  //필요한 값들 초기화
  var bodyStartPointLen = content[13].length;
  var bodyDataInner = {};
  
  var bodyIndexRow = 0; //log 정보를 담은 열이 시작되는 부분(action_id..........body)
  var bodyIndexDescription = 0; //log 정보를 담은 열이 시작되는 부분 아래의 인덱스 설명(state, action_no, gesture	area, label, name, ......)
  var bodyStartRow = 0; //실질적인 log정보가 시작되는 부분
  
  var bodyStartCol = 0; //body 값이 서술된 행(bodyIndexRow열에서 body의 위치)
  var content_typeCol = 0; //content_type 값이 서술된 행 (bodyIndexDescription열에서 content_type의 위치, 일반적으로 'bodyIndexRow열에서 body의 위치 - 1')
  
  //뭐 더 넣고 싶으면 아래 bodyDataInnerIndex, bodyDataInnerContent, bodyDataInnerLength 배열만 수정하면 됨
  //이 변수들도 하나로 통합하고 싶은데 (수정 예정) <- 복사 어케되는지 확인하고 수정
  //세 변수의 길이는 같아야 합니다.
  var bodyDataInnerIndex = ['state', 'gesture', 'area', 'label', 'body', 'content_type']; //bodyDataInner에 뭐 들어가는지
  var bodyDataInnerLength = [1, 3, 4, 5, lastRow, content_typeCol + 1]; //추출 길이 정보
  var bodyDataInnerContent = [0, 2, 3, 4, bodyStartCol, content_typeCol]; //추출 행 정보 (bodyStartCol이랑 content_typeCol이 일정하지 않아서 불편하게 됨 ㅠㅠ)
  
  var bodyDataInner = objGenerator(bodyDataInnerIndex); //bodyDataInnerIndex 값들을 key로, []을 value로 하는 객체 생성(초기화 용도)
  
  //이 범위는 조정 가능함(보통 row 15에 Index가 있으나 row 14나 row 13에 Index가 있는 정의서가 있어 추가됨)
  var searchStartRow = 12;
  var searchEndRow = 15;
  
  //for loop for searching bodyIndexRow(=ti)
  for(var ti = searchStartRow; ti < searchEndRow; ti++){ 
    //for loop for searching bodyStartCol(=tt)
    for(var tt = 0; tt < bodyStartPointLen; tt++){
      if(content[ti][tt].match(/body/)){ //Index부분에서 'body' 문자를 포함하는 열을 찾음 (=tt)
        bodyIndexRow = ti;
        bodyIndexDescription = ti + 1;
        bodyStartRow = ti + 2;
        
        bodyDataInnerContent[4] = tt; //body 정보가 시작되는 행
        bodyDataInnerContent[5] = tt - 1; //content_type 정보가 있을 것이라 예상되는 행
        bodyDataInnerLength[5] = tt;
        
        var content_typeFlag = false; //content_type 유무를 확인하기 위해 사용되는 변수. 없으면 false, 있으면 true
        
        //content_type 유무 검사
        //content_type 목록이 없는 정의서의 경우 bodyDataInner.content_type = []으로 처리됨
        var content_typePosition = content[bodyIndexRow + 1].indexOf('content_type'); //body정보 시작 다음 행에 content_type을 나타내는 index가 있는지 확인
        var content_typePositionFrombodyDataInnerIndex = bodyDataInnerIndex.indexOf('content_type'); //bodyInnerIndex에서의 content_type의 위치
        
        if(content_typePosition != -1){
          content_typeFlag = true;
        }else{
          bodyDataInnerIndex.splice(content_typePosition, 1);
        }
        
        //추출하지 않을 데이터들은 array에서 지우고 길이를 선언해야 함
        var bodyDataInnerMapLength = bodyDataInnerIndex.length;
        
        //배열들의 값을 종합하여 맵 생성
        for(var tk = bodyStartRow ; tk < lastRow ; tk++){
          for(var tkk = 0; tkk < bodyDataInnerMapLength; tkk++){
            bodyDataInner[bodyDataInnerIndex[tkk]].push(content[tk].slice(bodyDataInnerContent[tkk], bodyDataInnerLength[tkk]));
          }
        }
      }
    }
    
    if((ti == searchEndRow - 1) && (bodyDataInner == {})){
      //body start point를 찾지 못함
      throw "bodyStartPointNotFoundException"
    }
    
    if(bodyIndexRow != 0){
      break;
    }
  }
  
  //testLog('bodyDataInner : ' + JSON.stringify(bodyDataInner));
  return bodyDataInner;
}

///////////////////////////////////////////////////////////////////////////////for test
/************************** 결과 배열을 시트에 작성하는 함수 **************************/
function writeSheet(pSheet, arr){
  var sheet = pSheet;
  var newArr = arr;
  if(newArr == 1){
    return;
  }
  var lastRowOfTest = sheet.getLastRow();
  sheet.insertRows(2, newArr.length);
  sheet.getRange(2,1,newArr.length,8).setValues(newArr);
}

/************************** 오류 로그 배열을 작성하는 함수 **************************/
//오류 로그 배열을 받아 작성하는 함수
function logForVerification(msgLogArray){
  var messageArray = msgLogArray;
  
  var errorLogSheet = SpreadsheetApp.openById('1K6MpkMg_u2hkuG3V9pcWm1cyg7MqP_koiPa0I6qNeCY').getSheetByName('Error Log');
  errorLogSheet.insertRows(2, messageArray.length);
  var errorLogSheetRange = errorLogSheet.getRange(2, 1, messageArray.length);
  errorLogSheetRange.setValues(msgLogArray);
}

/************************** 시트를 clear하는 함수 **************************/
//테스트 시트 clear 용도
function sheetClear(){
  testLog("시트를 청소합니다.....");
  
  var spreadsheetForClear = SpreadsheetApp.openById('1K6MpkMg_u2hkuG3V9pcWm1cyg7MqP_koiPa0I6qNeCY');
  var sheetForClear = spreadsheetForClear.getSheets();
  var sheetForClearLength = sheetForClear.length;
  
  
  for(var ff = 1; ff < sheetForClearLength; ff++){
    testLog("대상 시트 이름 : " + sheetForClear[ff].getName());
    testLog("삭제할 열 수 : " + sheetForClear[ff].getMaxRows());
    
    sheetForClear[ff].deleteRows(3, sheetForClear[ff].getMaxRows() - 2);
  }
}

/************************** 테스트 로그를 작성하는 함수 **************************/
function testLog(msg){
  var _logSheet = SpreadsheetApp.openById('1K6MpkMg_u2hkuG3V9pcWm1cyg7MqP_koiPa0I6qNeCY').getSheetByName('Log');
  _logSheet.appendRow([msg]);
}

/************************** 캐시 update함수 **************************/
//오류 배열을 캐시에 저장함 (key : Errorlog)
//사용하지 않음
function updateCahceErrorArray(errorArray){
  var cache = CacheService.getScriptCache();
  var lastData = cache.get('Errorlog');
  
  if(lastData != null){
    cache.remove('Errorlog');
    var newData = JSON.stringify(JSON.parse(lastData).concat(errorArray));
    
    cache.put('Errorlog', newData, 21600);
  }else{
    var newData = JSON.stringify(errorArray);
    
    cache.put('Errorlog', newData, 21600);
  }
}

/************************** 캐시 삭제 함수 **************************/
function cacheClear(targetKey){
  var cache = CacheService.getScriptCache();
  
  cache.remove('11IX5K634rEQsteK_1exNhT9pE3b6UoR-ldvWQzbWr-A:1682174724');
}

/************************** 시트 오류 정리를 위한 함수 **************************/
function errorClear(){
  var spreadsheetURL = 'https://docs.google.com/spreadsheets/d/1MDBxT59cv_DNYNjJjaMTkCDcZ3x2eeAa8jz7gXrrGZY/edit#gid=1493159822'; //정리할 스프레드 시트 아이디
  var sheetID = /gid=([0-9]+)/.exec(spreadsheetURL)[1];
  
  if((sheetID == '1493159822') || (sheetID == '477138302')){
    var sheetName = 'MW/APP'
  }else if((sheetID == '1682174724') || (sheetID =='2064939330') || (sheetID =='1534264271') || (sheetID =='872340418')|| (sheetID =='1810614817')){
    var sheetName = 'PC'
  }
  
  var spreadsheet = SpreadsheetApp.openByUrl(spreadsheetURL);
  var sheet = spreadsheet.getSheetByName(sheetName);
  
  var lastCol = sheet.getLastColumn();
  var lastRow = sheet.getLastRow();
  
  var content = sheet.getRange(1, 1, lastRow, lastCol).getValues();
  
  if((content[17][2] == '') && (content[17][3] == '') && (content[17][4] == '')){
    if(content[17][1] == 3){
      sheet.deleteRows(18, 968);
    }
  }
}

//legacy

/************************** 정의서 검증 함수 **************************/
//오류메세지는 정말 대략적인 정보만 적었음
//passedSheet로 받은 정의서를 읽어서 정의서 정보 또는 오류 정보를 array로 리턴
//함수에서 생성된 배열을 verificationArray함수에서 검사 
//오류 유무에 따라 함수가 return하는 결과값이 달라짐

//오류는 verificationArray에서 핸들링하나 보다 명확한 오류 메세지를 출력하기 위해 일부 오류는 예외로 지정하여 readEachSheet 함수에서 직접 핸들링
// 1) lastRow와 lastColumn이 기준 미달인 경우
// 2) body 시작 기준점을 찾을 수 없을 경우
// 3) 재귀함수로 모듈정의서를 받지 않고 main함수에서 직접 모듈정의서를 parameter로 받은 경우

//poc_clf 추가 유연하게 대처 가능하도록 poc_clf 핸들링 function이나 객체로 빼서 처리

//passedObject = {PageAttribute : [page_id, [poc_clf], [os_name]], BodyAttribute : [[state, action_id, body(JSON)]], SpreadSheetID : spreadSheetID, SheetID : sheetID, TimeStamp : timeStamp, errorList : []}
function readEachSheet(passedSpreadSheetID, passedSheet, passedTime, pocForModule){//main에서 받는 parameter은 3개
  var spreadSheetID = passedSpreadSheetID;
  var targetSheet = passedSheet;
  var timeStamp = passedTime;
  
  var sheetID = targetSheet.getSheetId();
  var lastRow = targetSheet.getLastRow();
  var lastColumn = targetSheet.getLastColumn();
  
  //lastRow와 lastColumn을 가져올 수 없는 경우 오류 캐치
  
  //00일 때 exception 추가
  //
  try{
    var content = targetSheet.getRange(1, 1, lastRow, lastColumn).getValues();
  }catch(e){
    return {errorList : [["https://docs.google.com/spreadsheets/d/" + spreadSheetID + "/edit#gid=" + sheetID],["  [system] 행과 열 정보를 읽어올 수 없습니다."]]};
  }
  
  var ObjectForExamination = {
    PageAttribute : [], 
    BodyAttribute : [],
    SpreadSheetID : spreadSheetID,
    SheetID : sheetID,
    TimeStamp : timeStamp
  } //{PageAttribute : [page_id, [poc_clf], [os_name]], BodyAttribute : [[state, action_id, body(JSON)]], SpreadSheetID : spreadSheetID, SheetID : sheetID, TimeStamp : timeStamp}
  var returnArray = [];
  
  //content object 처리
  
  //오류 핸들링은 if분기로 검증 후 배열에 '행 번호'로 저장, 배열에 저장된 오류를 verificationArray에서 검증
  //오류시 flag on, 마지막까지 flag가 off인 경우 검증 로직 건너뜀. (attri 따로, body 따로)(나중)
  /************************** PageAttribute 핸들링 **************************/
  var counterForAttribute = content[4].length; //poc 구분 행, poc for loop시 사용 //스펠링 다름~~~~ 나중에 수정~~~
  
  //일반 정의서와 모듈 정의서로 분기
  ObjectForExamination.PageAttribute[1] = [];
  ObjectForExamination.PageAttribute[2] = [];
  
  //1. 일반 정의서인 경우
  if(!content[0][0].match(/module 정의서/)){
    //page_id
    //페이지 ID 행에 값이 있는가만 검증, 틀린 값 여부는 검증하지 않음
    if(content[2][1] != ""){
      ObjectForExamination.PageAttribute[0] = content[2][1];
    }else{
      //page_id 없음 오류
      ObjectForExamination.PageAttribute[0] = 3;
    }
    
    //poc_clf
    //os_name
    //시트 이름에 따라 POC 분기를 다르게 (나중에)
    for(var p = 1; p < counterForAttribute; p++){
      if(content[4][p] != ""){
        if(content[4][p] == 'MW'){
          ObjectForExamination.PageAttribute[1].push('mw')
          ObjectForExamination.PageAttribute[2].push('');
        }else if(content[4][p] == 'APP(Android)'){
          ObjectForExamination.PageAttribute[1].push('app');
          ObjectForExamination.PageAttribute[2].push('Android');
        }else if(content[4][p] == 'APP(iOS)'){
          ObjectForExamination.PageAttribute[1].push('app');
          ObjectForExamination.PageAttribute[2].push('iOS');
        }else if(content[4][p] == 'PC'){
          ObjectForExamination.PageAttribute[1].push('pc');
          ObjectForExamination.PageAttribute[2].push('');
        }else{
          //POC구분 오류(MW, APP(iOS), APP(Android), PC <= 4개의 경우가 아니면 오류)
          ObjectForExamination.PageAttribute[1].push(5);
          ObjectForExamination.PageAttribute[2].push(5);
        }
      }else if(content[4][p] == ""){
        //행에서 POC정보가 더는 없으면 loop 탈출
        if(content[4][p+1]){
          //poc_clf에 공란이 있는 경우
          if(content[4][p+1] != ""){
            ObjectForExamination.PageAttribute[1].push(5);
            ObjectForExamination.PageAttribute[2].push(5);
          }else{
            //content[4] 범위를 넘어가는 경우가 없을 것 같아서 content[4] 행을 넘어가는 경우를 고려하지 않음.
            //POC정보를 전부 추출 완료하면 for loop break
            break;
          }
        }else if(content[4][p+1] == ''){
          if(p == 1){
            //poc_clf 정보가 아예 없는 경우
            ObjectForExamination.PageAttribute[1].push(5);
            ObjectForExamination.PageAttribute[2].push(5);
            break;
          }
        }
      }
    }
  //2. 모듈정의서인 경우
  }else if(content[0][0].match(/module 정의서/)){ 
    if(pocForModule){ //재귀함수 호출인 경우 poc_clf 정보를 parameter에서 받는다
      //page_id
      //모듈의 경우 page_id 검증은 생략
      ObjectForExamination.PageAttribute[0] = 'module';
      
      //일반 정의서의 POC와 모듈정의서의 POC가 다른 경우가 있음. 여기서 해당 경우 핸들링(나중)
      for(var p = 1; p < counterForAttribute; p++){
        if(content[4][p] != ""){
          if(content[4][p] == 'MW'){
            ObjectForExamination.PageAttribute[1].push('mw')
            ObjectForExamination.PageAttribute[2].push('');
          }else if(content[4][p] == 'APP(Android)'){
            ObjectForExamination.PageAttribute[1].push('app');
            ObjectForExamination.PageAttribute[2].push('Android');
          }else if(content[4][p] == 'APP(iOS)'){
            ObjectForExamination.PageAttribute[1].push('app');
            ObjectForExamination.PageAttribute[2].push('iOS');
          }else if(content[4][p] == 'PC'){
            ObjectForExamination.PageAttribute[1].push('pc');
            ObjectForExamination.PageAttribute[2].push('');
          }else{
            //POC구분 오류(MW, APP(iOS), APP(Android), PC <= 4개의 경우가 아니면 오류)
            ObjectForExamination.PageAttribute[1].push(5);
            ObjectForExamination.PageAttribute[2].push(5);
          }
        }else if(content[4][p] == ""){
          //행에서 POC정보가 더는 없으면 loop 탈출
          if(content[4][p+1]){
            //poc_clf에 공란이 있는 경우
            if(content[4][p+1] != ""){
              ObjectForExamination.PageAttribute[1].push(5);
              ObjectForExamination.PageAttribute[2].push(5);
            }else{
              //POC정보를 전부 추출 완료하면 for loop break
              break;
            }
          }else if(content[4][p+1] == ''){
            if(p == 1){
              //poc_clf 정보가 아예 없는 경우
              ObjectForExamination.PageAttribute[1].push(5);
              ObjectForExamination.PageAttribute[2].push(5);
              break;
            }
          }
        }//content[4] 범위를 넘어가는 경우가 없을 것 같아서 content[4] 행을 넘어가는 경우를 고려하지 않음.
      }
    }else{
      //module 정의서를 parameter로 받은 경우
      //별도의 검증이나 로그 없이 1을 리턴함.
      return {errorList : [["모듈 정의서를 스킵합니다."]]}; //리턴 값 검토 (오류 메세지가 필요할까요..............)
    }
  }
  
  /************************* BodyArrtibute 핸들링 ***************************/
  var bodyStartPoint = 0; //body값이 시작되는 열
  var bodyDataStartRow = 0; //body 데이터 읽기가 시작되는 행
  
  //body인덱스 조정
  for(var i = 0; i < content[13].length; i++){
    if(content[13][i].match(/body/)){
      bodyStartPoint = i;
      bodyDataStartRow = 15;
      break;
    }
  }
  if(bodyStartPoint == 0){
    //14열이 아닌 부분에 body 기준점이 있는 issue때문에 추가된 코드
    //body 기준점이 없는 경우 그 다음 열을 검사함.
    for(i = 0; i< content[14].length; i++){
      if(typeof content[14][i] == 'string'){
        if(content[14][i].match(/body/)){
          bodyStartPoint = i;
          bodyDataStartRow = 16;
          break;
        }
      }
    }
    if(bodyStartPoint == 0){
      //body 검사 이전에 걸리는 오류이므로 배열검사 실행 불가능
      //body값 검사 없이 배열 생성 가능하지만 의미 없을 것 같아서 바로 오류메세지 리턴
      return {errorList : [["https://docs.google.com/spreadsheets/d/" + spreadSheetID + "/edit#gid=" + sheetID],["  [system] body값의 기준점을 찾을 수 없습니다."]]}; //리턴 값 검토
    }
  }
  
  //임시 코드
  if(bodyDataStartRow == 0){
    bodyDataStartRow = 15;
  }
  
  var counterForMapping = lastColumn - bodyStartPoint; //body값이 있는 표 부분만 추출하기 위함
  var temp = [];
  var arrLength = 0;
  
  for(var j = bodyDataStartRow; j < lastRow; j++){
    //2차원 배열
    arrLength = ObjectForExamination.BodyAttribute.length;
    ObjectForExamination.BodyAttribute[arrLength] = [];
    temp[arrLength] = [];
        
    //actionID, state
    if(content[j][0] != ''){
      //state
      if(content[j][0] == '서비스중' || '삭제' || '추가' || '수정'){
        ObjectForExamination.BodyAttribute[arrLength][0] = content[j][0];
      }else{
        //state오류
        ObjectForExamination.BodyAttribute[arrLength][0] = j + 1;
      }
      
      //action_id
      //page_show, dom_content_loaded는 따로 핸들링
      if((content[j][2] != 'page_show') && (content[j][2] != 'dom_content_loaded')){
      //gesture, area, label을 합쳐 action_id 생성
        if((content[j][2] != '') && (content[j][3] != '') && (content[j][4] != '')){
          ObjectForExamination.BodyAttribute[arrLength][1] = content[j][2] + "." + content[j][3] + "." + content[j][4];
        }else{
          //gesture, area, label 중 하나라도 비어있으면 actionID 오류
          ObjectForExamination.BodyAttribute[arrLength][1] = j + 1; //(오류)actionID 비어있는 오류
        }
        //page_show와 dom_content_loaded는 따로 핸들링
      }else if((content[j][2] == 'page_show') || (content[j][2] == 'dom_content_loaded')){
        //합칠 필요 없이 page_show나 dom_content_loaded를 그대로 배열에 저장
        ObjectForExamination.BodyAttribute[arrLength][1] = content[j][2];
      }
    //빈 열 오류 방지를 위함
    }else if(content[j][0] == ''){
      if((content[j][2] != '') && (content[j][3] != '') && (content[j][4] != '')){
        //state 없는 경우
        ObjectForExamination.BodyAttribute[arrLength][0] = j + 1;
        ObjectForExamination.BodyAttribute[arrLength][1] = content[j][2] + "." + content[j][3] + "." + content[j][4];
      }else{
        //state도 없고 action_id도 없는 경우
        ObjectForExamination.BodyAttribute[arrLength][0] = j + 1;
        ObjectForExamination.BodyAttribute[arrLength][1] = j + 1;
      }
      //두 줄 이상 행에 내용이 없는 경우 
      if(content[j+1]){ 
        //[j+1]에 대한 검사를 하지 않고 [j+1][2]를 호출하면 오류 발생하므로 검사해야함.
        if(content[j+1][2] == ''){//content[j+1][2] == ''만 검증하게 됨.....
          ObjectForExamination.BodyAttribute.pop(); //이전 행도 내용이 없고 이후 행도 내용이 없으므로 이전 행 삭제, 앞으로의 행에도 내용이 없을 것이므로 break for-loop
          break;
        }
      }
    }
        
    //body(JSON)
    //body array도 생성 가능(억제)
    //body중복 제거(나중)
    content[j].slice(bodyStartPoint, lastColumn).map(function(obj, idx){
      if(obj != ''){
        temp[arrLength].push("\""+obj+"\"");
      }
      if(idx == counterForMapping - 1){
        //body(JSON)
        ObjectForExamination.BodyAttribute[arrLength][2] = "{body:[" + temp[arrLength].join(',') + "]}";        
      }
      return obj;
    }).filter(function(x){
      //body array 사이에 빈 칸이 있는 경우 핸들링
      return x != '';
    });
      
    //undefined 핸들링
    if(returnArray[arrLength] == undefined){
      //verificationArray(targetArray)에서 처리하기
    }
  }
  
  testLog("모듈 여부 확인");
  /************************* 모듈 포함 여부 검사 ***************************/
  if(content[11][1] != ''){
    testLog("모듈이 있습니다.");
    //속성에 오류가 있는 경우 모듈정의서 처리 돌지 않음. poc와 os_name, page_id가 옳은 경우에만 모듈 정의서 처리를 돌림(나중)
    if(content[11][1].match(/https/)){
      var moduleSpreadSheetID = /spreadsheets\/d\/([a-zA-Z0-9-_]+)/.exec(content[11][1].toString())[1]; //정규식 캡처 방식이라 return이 array임
      var moduleSheetID =  /gid=([0-9]+)/.exec(content[11][1].toString())[1]; //정규식 캡처 방식이라 return이 array임
      
      //module 서치 함수 호출
      var moduleSpreadSheet = SpreadsheetApp.openById(moduleSpreadSheetID);
      var moduleSpreadSheetName = moduleSpreadSheet.getName();
      var moduleSheet = searchSheet(moduleSpreadSheet, moduleSheetID);
      
      //var moduleSheet = searchSheet(moduleSheetID); //캐시에 있는 시트인지 검사한 후 검사 결과에 따라 분기하는 함수
      //재귀함수 호출 후 body만 저장
      testLog("모듈을 생성합니다.");
      var objectForModuleBody = readEachSheet(moduleSpreadSheetID, moduleSheet, timeStamp, ObjectForExamination.PageAttribute[0]);
      //module 정의서에 오류가 있을 경우 body를 합치지 않음
      testLog("objectForModuleBody : " + JSON.stringify(objectForModuleBody));
      if(objectForModuleBody.processList){
        testLog("모듈을 정상적으로 읽었습니다.");
        ObjectForExamination.BodyAttribute = ObjectForExamination.BodyAttribute.concat(objectForModuleBody.processList);
      }else if(objectForModuleBody.errorList){
        testLog("모듈에 오류가 있습니다.");
      }else{
        testLog("????");
      }
    }
  }
  return verificationArray(ObjectForExamination);
}